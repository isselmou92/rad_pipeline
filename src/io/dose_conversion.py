#!/usr/bin/env python3
"""
dose_conversion.py
──────────────────
Verify that a NumPy dose volume matches a template RT-Dose DICOM,
convert an LET NumPy volume to uint16 + DoseGridScaling, write a
standard-compliant LET RT-Dose DICOM, then read it back to confirm
round-trip fidelity (≤ 1 stored unit).

Identical maths to the original *convert_let_to_dose.py*; only the
hard-coded file paths were replaced by command-line arguments.

Usage
-----
python -m rad_pipeline.io.dose_conversion \
    template_dose.dcm dose.npy let.npy updated_let.dcm
"""
from __future__ import annotations

import argparse
import copy
import os
import sys
from pathlib import Path

import numpy as np
import pydicom


# ── helper functions ──────────────────────────────────────────────────────
def load_float_volume(path: str | Path) -> np.ndarray:
    """Load a 3-D float32 NumPy array (frames, rows, cols)."""
    arr = np.load(path).astype(np.float32)
    if arr.ndim != 3:
        raise ValueError(f"{path}: expected 3-D (frames, rows, cols) got {arr.shape}")
    return arr


def float_to_uint16(vol: np.ndarray) -> tuple[np.ndarray, float]:
    """Scale a float volume to uint16 while returning the scale factor."""
    vmax = float(vol.max())
    scale = 1.0 if vmax == 0 else vmax / 65535.0
    return np.round(vol / scale).astype(np.uint16), scale


def verify_volume(ds: pydicom.Dataset, arr_phys: np.ndarray, label: str) -> None:
    """
    Confirm that *arr_phys* matches the physical voxel values in *ds*
    to within ±1 integer step (DoseGridScaling).
    """
    raw_int = ds.pixel_array.astype(np.float32)
    dgsc = float(ds.DoseGridScaling)
    max_diff = np.abs(raw_int * dgsc - arr_phys).max()
    allowed = dgsc + 1e-9  # tiny epsilon

    if max_diff > allowed:
        raise ValueError(
            f"{label} verification failed: |Δ|max = {max_diff:.6g} "
            f"(allowed ≤ {allowed:.6g} = 1 LSB)"
        )
    print(f"✓ {label} verification passed (≤ 1 stored unit).")


def write_let_dicom(
    template_ds: pydicom.Dataset,
    let_uint16: np.ndarray,
    scale: float,
    outfile: str | Path,
) -> None:
    """Clone *template_ds* and insert LET pixel data + metadata tweaks."""
    ds = copy.deepcopy(template_ds)

    f, r, c = let_uint16.shape
    ds.NumberOfFrames, ds.Rows, ds.Columns = f, r, c

    ds.PixelData = let_uint16.tobytes()
    ds.BitsAllocated = ds.BitsStored = 16
    ds.HighBit = 15
    ds.PixelRepresentation = 0  # unsigned
    ds.DoseGridScaling = float(scale)

    # metadata tweaks so viewers recognise it as a separate series
    ds.DoseUnits = "RELATIVE"  # Gy | RELATIVE
    ds.DoseComment = "LET (keV/µm) – generated by Python script"
    ds.SeriesDescription = "LET map (keV/µm)"
    ds.SOPInstanceUID = pydicom.uid.generate_uid()

    ds.save_as(str(outfile))
    print(
        f"✓ wrote {outfile}\n"
        f"  DoseGridScaling = {scale:.6g}  "
        f"(1 stored unit = {scale:.6g} keV/µm)\n"
    )


# ── CLI entry point ───────────────────────────────────────────────────────
def _parse_args() -> argparse.Namespace:
    p = argparse.ArgumentParser(
        description="Convert an LET NumPy volume to a standard RT-Dose DICOM."
    )
    p.add_argument("template_dose", help="Template RT-Dose DICOM (reference geometry)")
    p.add_argument("dose_npy", help="Dose volume .npy (Gy) – for verification")
    p.add_argument("let_npy", help="LET volume .npy (keV/µm)")
    p.add_argument(
        "out_let_dcm",
        nargs="?",
        default="updated_let.dcm",
        help="Output LET DICOM file (default: updated_let.dcm)",
    )
    return p.parse_args()


def main() -> None:
    args = _parse_args()

    for path in (args.template_dose, args.dose_npy, args.let_npy):
        if not os.path.isfile(path):
            sys.exit(f"File not found: {path}")

    tmpl_ds = pydicom.dcmread(args.template_dose)

    # 1) verify dose
    dose_np = load_float_volume(args.dose_npy)
    verify_volume(tmpl_ds, dose_np, "Dose")

    # 2) convert LET to uint16 + scale
    let_np = load_float_volume(args.let_npy)
    let_u16, let_scale = float_to_uint16(let_np)

    # 3) write LET DICOM
    write_let_dicom(tmpl_ds, let_u16, let_scale, args.out_let_dcm)

    # 4) read back and verify LET
    let_ds = pydicom.dcmread(args.out_let_dcm)
    verify_volume(let_ds, let_np, "LET")

    print("All checks passed –", args.out_let_dcm, "is ready for 3D Slicer.")


if __name__ == "__main__":
    main()
